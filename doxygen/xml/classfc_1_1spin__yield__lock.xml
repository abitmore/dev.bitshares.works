<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="classfc_1_1spin__yield__lock" kind="class" language="C++" prot="public">
    <compoundname>fc::spin_yield_lock</compoundname>
    <includes refid="spin__yield__lock_8hpp" local="no">spin_yield_lock.hpp</includes>
      <sectiondef kind="private-type">
      <memberdef kind="enum" id="classfc_1_1spin__yield__lock_1a43fa8d6a058deda213d7c501e2c96b10" prot="private" static="no">
        <name>lock_store</name>
        <enumvalue id="classfc_1_1spin__yield__lock_1a43fa8d6a058deda213d7c501e2c96b10a913d91ddbe281204b4762c3a89394c70" prot="private">
          <name>locked</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="classfc_1_1spin__yield__lock_1a43fa8d6a058deda213d7c501e2c96b10a3bcefb95cc4189bb16f0d805a6f3054b" prot="private">
          <name>unlocked</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/fc/include/fc/thread/spin_yield_lock.hpp" line="30" column="1" bodyfile="libraries/fc/include/fc/thread/spin_yield_lock.hpp" bodystart="30" bodyend="30"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classfc_1_1spin__yield__lock_1adca9135036a0287c4a2f8573c4f04c10" prot="private" static="no" mutable="no">
        <type>int</type>
        <definition>int fc::spin_yield_lock::_lock</definition>
        <argsstring></argsstring>
        <name>_lock</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/fc/include/fc/thread/spin_yield_lock.hpp" line="31" column="1" bodyfile="libraries/fc/include/fc/thread/spin_yield_lock.hpp" bodystart="31" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classfc_1_1spin__yield__lock_1a83bdef9ef38336137f76cb7a7898306d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>fc::spin_yield_lock::spin_yield_lock</definition>
        <argsstring>()</argsstring>
        <name>spin_yield_lock</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/fc/include/fc/thread/spin_yield_lock.hpp" line="22" column="1" bodyfile="libraries/fc/src/thread/spin_yield_lock.cpp" bodystart="12" bodyend="18"/>
      </memberdef>
      <memberdef kind="function" id="classfc_1_1spin__yield__lock_1a835c9c38c66f71cfcbdb659a358baa19" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool fc::spin_yield_lock::try_lock</definition>
        <argsstring>()</argsstring>
        <name>try_lock</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/fc/include/fc/thread/spin_yield_lock.hpp" line="23" column="1" bodyfile="libraries/fc/src/thread/spin_yield_lock.cpp" bodystart="20" bodyend="23"/>
      </memberdef>
      <memberdef kind="function" id="classfc_1_1spin__yield__lock_1a71a750257e6675c1a286e80cabc31adc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool fc::spin_yield_lock::try_lock_for</definition>
        <argsstring>(const microseconds &amp;rel_time)</argsstring>
        <name>try_lock_for</name>
        <param>
          <type>const <ref refid="classfc_1_1microseconds" kindref="compound">microseconds</ref> &amp;</type>
          <declname>rel_time</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/fc/include/fc/thread/spin_yield_lock.hpp" line="24" column="1" bodyfile="libraries/fc/src/thread/spin_yield_lock.cpp" bodystart="25" bodyend="27"/>
      </memberdef>
      <memberdef kind="function" id="classfc_1_1spin__yield__lock_1afabf0a7d6e2f72be191f94e81e80dbc0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool fc::spin_yield_lock::try_lock_until</definition>
        <argsstring>(const time_point &amp;abs_time)</argsstring>
        <name>try_lock_until</name>
        <param>
          <type>const <ref refid="classfc_1_1time__point" kindref="compound">time_point</ref> &amp;</type>
          <declname>abs_time</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/fc/include/fc/thread/spin_yield_lock.hpp" line="25" column="1" bodyfile="libraries/fc/src/thread/spin_yield_lock.cpp" bodystart="29" bodyend="36"/>
      </memberdef>
      <memberdef kind="function" id="classfc_1_1spin__yield__lock_1ac3cd1fdfd2178f1a853b198c0376cce2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void fc::spin_yield_lock::lock</definition>
        <argsstring>()</argsstring>
        <name>lock</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/fc/include/fc/thread/spin_yield_lock.hpp" line="26" column="1" bodyfile="libraries/fc/src/thread/spin_yield_lock.cpp" bodystart="38" bodyend="43"/>
      </memberdef>
      <memberdef kind="function" id="classfc_1_1spin__yield__lock_1a71054710dbef2a6ea7f19260f6053931" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void fc::spin_yield_lock::unlock</definition>
        <argsstring>()</argsstring>
        <name>unlock</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="libraries/fc/include/fc/thread/spin_yield_lock.hpp" line="27" column="1" bodyfile="libraries/fc/src/thread/spin_yield_lock.cpp" bodystart="45" bodyend="48"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>modified spin-lock that yields on failure, but becomes a &apos;spin lock&apos; if there are no other tasks to yield to. </para>    </briefdescription>
    <detaileddescription>
<para>This kind of lock is lighter weight than a full mutex, but potentially slower than a staight <ref refid="classfc_1_1spin__lock" kindref="compound">spin_lock</ref>.</para><para>This <ref refid="classfc_1_1spin__yield__lock" kindref="compound">spin_yield_lock</ref> does not block the current thread, but instead attempts to use an atomic operation to aquire the lock. If unsuccessful, then it yields to other tasks before trying again. If there are no other tasks then yield is a no-op and <ref refid="classfc_1_1spin__yield__lock" kindref="compound">spin_yield_lock</ref> becomes a spin-lock. </para>    </detaileddescription>
    <location file="libraries/fc/include/fc/thread/spin_yield_lock.hpp" line="20" column="1" bodyfile="libraries/fc/include/fc/thread/spin_yield_lock.hpp" bodystart="20" bodyend="32"/>
    <listofallmembers>
      <member refid="classfc_1_1spin__yield__lock_1adca9135036a0287c4a2f8573c4f04c10" prot="private" virt="non-virtual"><scope>fc::spin_yield_lock</scope><name>_lock</name></member>
      <member refid="classfc_1_1spin__yield__lock_1ac3cd1fdfd2178f1a853b198c0376cce2" prot="public" virt="non-virtual"><scope>fc::spin_yield_lock</scope><name>lock</name></member>
      <member refid="classfc_1_1spin__yield__lock_1a43fa8d6a058deda213d7c501e2c96b10" prot="private" virt="non-virtual"><scope>fc::spin_yield_lock</scope><name>lock_store</name></member>
      <member refid="classfc_1_1spin__yield__lock_1a43fa8d6a058deda213d7c501e2c96b10a913d91ddbe281204b4762c3a89394c70" prot="private" virt="non-virtual"><scope>fc::spin_yield_lock</scope><name>locked</name></member>
      <member refid="classfc_1_1spin__yield__lock_1a83bdef9ef38336137f76cb7a7898306d" prot="public" virt="non-virtual"><scope>fc::spin_yield_lock</scope><name>spin_yield_lock</name></member>
      <member refid="classfc_1_1spin__yield__lock_1a835c9c38c66f71cfcbdb659a358baa19" prot="public" virt="non-virtual"><scope>fc::spin_yield_lock</scope><name>try_lock</name></member>
      <member refid="classfc_1_1spin__yield__lock_1a71a750257e6675c1a286e80cabc31adc" prot="public" virt="non-virtual"><scope>fc::spin_yield_lock</scope><name>try_lock_for</name></member>
      <member refid="classfc_1_1spin__yield__lock_1afabf0a7d6e2f72be191f94e81e80dbc0" prot="public" virt="non-virtual"><scope>fc::spin_yield_lock</scope><name>try_lock_until</name></member>
      <member refid="classfc_1_1spin__yield__lock_1a71054710dbef2a6ea7f19260f6053931" prot="public" virt="non-virtual"><scope>fc::spin_yield_lock</scope><name>unlock</name></member>
      <member refid="classfc_1_1spin__yield__lock_1a43fa8d6a058deda213d7c501e2c96b10a3bcefb95cc4189bb16f0d805a6f3054b" prot="private" virt="non-virtual"><scope>fc::spin_yield_lock</scope><name>unlocked</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
